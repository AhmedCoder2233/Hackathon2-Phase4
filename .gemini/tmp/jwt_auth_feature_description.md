# JWT Authentication & User ID Retrieval - Implementation Specification ## Overview Implement JWT token validation and user identification system for the `/support/chatkit` endpoint in FastAPI backend. ## Objective When a request hits `/support/chatkit`, validate the Better Auth JWT token, extract user information, and retrieve the associated user_id from the sessions table. ## Current State - **File Location**: `backend/app/main.py` - **Endpoint**: `POST /support/chatkit` - **Current Behavior**: JWT token is received in Authorization header as `Bearer 0fOyRVonMqRyD20kP9Qi` but not validated - **Token Format**: Better Auth JWT token (e.g., `0fOyRVonMqRyD20kP9Qi`) ## Database Schema ### User Table (`public.user`) ```sql Columns: - id (TEXT, PRIMARY KEY) - name (TEXT) - email (TEXT, UNIQUE, NOT NULL) - emailVerified (BOOLEAN, DEFAULT false) - image (TEXT) - createdAt (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP) - updatedAt (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP) - sessions (RELATIONSHIP to Session table) ``` ### Session Table (`public.session`) ```sql Columns: - id (TEXT, PRIMARY KEY) - userId (TEXT, FOREIGN KEY -> public.user.id) - expiresAt (TIMESTAMP) - token (TEXT) - ipAddress (TEXT) - userAgent (TEXT) ``` **Relationship**: User table has a `sessions` column that relates to the Session table via `userId` ## Implementation Requirements ### 1. JWT Token Validation - **Input**: JWT token from `Authorization` header (format: `Bearer <token>`) - **Process**: - Extract token from header - Validate JWT token using Better Auth configuration - Decode token to extract payload (including email) - **Output**: Decoded payload with user email ### 2. Database Query Flow **Step 1**: Extract email from JWT payload ```python email = decoded_token['email'] # or appropriate field from Better Auth JWT ``` **Step 2**: Query User table by email ```sql SELECT * FROM public.user WHERE email = :email ``` **Step 3**: Access related sessions ```python user = db.query(User).filter(User.email == email).first() sessions = user.sessions # Access relationship ``` **Step 4**: Extract user_id from sessions ```python for session in sessions: print(f"User ID: {session.userId}") ``` ### 3. Expected Output Print the `user_id` from the session table that is associated with the matched user. ```python print(f"âœ… User ID from session: {session.userId}") ``` ## Implementation Steps ### Step 1: Install Required Dependencies ```bash pip install python-jose[cryptography] sqlalchemy psycopg2-binary ``` ### Step 2: Create Database Models - File: `backend/app/database.py` - Create SQLAlchemy models for User and Session tables - Define relationship between tables - Setup database connection to NeonDB ### Step 3: Create JWT Validation Utility - File: `backend/app/auth.py` - Implement JWT decode and validation function - Handle Better Auth JWT token format - Extract email from token payload ### Step 4: Update `/support/chatkit` Endpoint - File: `backend/app/main.py` - Add JWT validation before processing request - Query database for user by email - Access sessions relationship - Print user_id from sessions - Return appropriate error responses for invalid tokens ## Error Handling ### Invalid Token ```json { "error": "Invalid or expired JWT token", "status": 401 } ``` ### User Not Found ```json { "error": "User not found with provided email", "status": 404 } ``` ### No Active Sessions ```json { "error": "No active sessions found for user", "status": 404 } ``` ## Environment Variables Required ```env DATABASE_URL=postgresql://user:password@neondb-host/database BETTER_AUTH_SECRET=your_better_auth_secret_key BETTER_AUTH_ISSUER=your_issuer # Optional ``` ## Success Flow Example ### Request ```http POST /support/chatkit Authorization: Bearer 0fOyRVonMqRyD20kP9Qi Content-Type: application/json { "message": "Hello" } ``` ### Processing 1. Extract token: `0fOyRVonMqRyD20kP9Qi` 2. Validate JWT âœ… 3. Extract email: `user@example.com` 4. Query database: Find user with `email = 'user@example.com'` 5. Access sessions: `user.sessions` 6. Print: `User ID: abc123xyz` ### Response ```http HTTP/1.1 200 OK Content-Type: text/event-stream [Normal ChatKit response continues...] ``` ### Console Output ``` ðŸ”‘ JWT Token: 0fOyRVonMqRyD20kP9Qi... âœ… JWT Validated ðŸ“§ Email from token: user@example.example.com ðŸ‘¤ User found: John Doe (ID: user_abc123) ðŸ”— Sessions found: 2 âœ… User ID from session: abc123xyz ``` ## Testing Checklist - [ ] Valid JWT token returns user_id - [ ] Invalid JWT token returns 401 error - [ ] Expired JWT token returns 401 error - [ ] Non-existent email returns 404 error - [ ] User with no sessions handles gracefully - [ ] Database connection errors handled - [ ] CORS headers still work correctly ## Additional Notes - Keep existing ChatKit functionality intact - JWT validation should happen before ChatKit processing - User context should be available throughout the request - Consider adding user_id to the request context for downstream use - Log all authentication attempts for security monitoring ## Success Criteria âœ… JWT token is validated on every `/support/chatkit` request âœ… Email is extracted from valid JWT token âœ… User is found in database by email âœ… Sessions relationship is accessed correctly âœ… User ID from sessions table is printed to console âœ… Invalid tokens return appropriate error responses âœ… Existing ChatKit functionality remains unaffected